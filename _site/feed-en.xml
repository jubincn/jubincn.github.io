<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bin's Blog</title>
    <description>Bin's Blog
</description>
    <link>http://localhost:4000/index.html</link>
    <atom:link href="http://localhost:4000/feed-en.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 12 Dec 2018 08:55:27 +0800</pubDate>
    <lastBuildDate>Wed, 12 Dec 2018 08:55:27 +0800</lastBuildDate>
    <generator>Jekyll v3.6.3</generator>
    
    
      <item>
        <title>Android Binder Study Note</title>
        <description>&lt;h2 id=&quot;tldr&quot;&gt;TL,DR&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Driver based IPC.&lt;/li&gt;
  &lt;li&gt;There is only one copy for Binder IPC and hence its efficient.
    &lt;ul&gt;
      &lt;li&gt;For client: Copy data from user space to kernel space, 1 time.&lt;/li&gt;
      &lt;li&gt;For server: Using mmap to share response memory, 0 time.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;how-to-find-service&quot;&gt;How to find service?&lt;/h2&gt;
&lt;p&gt;Binder token is used to locate service and they are registered in ServiceManager. There is a default locater with fixed token(seems to be 0) and client will ask locater for address.&lt;/p&gt;

&lt;h2 id=&quot;why-use-binder-instead-of-other-linux-ipc&quot;&gt;Why use Binder instead of other Linux IPC?&lt;/h2&gt;
&lt;p&gt;Shared memory is more efficient but its also error-prone. Pipe and message queue is less efficient since they need 2 memory copy.&lt;/p&gt;

&lt;h2 id=&quot;security-model&quot;&gt;Security model&lt;/h2&gt;
&lt;p&gt;Based on UID and PID, and filters to guarantee security.&lt;/p&gt;

&lt;h2 id=&quot;async-or-sync&quot;&gt;Async or sync?&lt;/h2&gt;
&lt;p&gt;Synchronous.&lt;/p&gt;

&lt;h2 id=&quot;reference-counting&quot;&gt;Reference Counting&lt;/h2&gt;
&lt;p&gt;Since Binder object is shared by another process, Binder use reference counting to track it.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35519585&quot;&gt;写给 Android 应用工程师的 Binder 原理剖析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.dre.vanderbilt.edu/~schmidt/cs282/PDFs/android-binder-ipc.pdf&quot;&gt;Android Binder IPC pdf&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/articles/2018/11/19/android-binder-study-note.html</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2018/11/19/android-binder-study-note.html</guid>
        
        
        <category>articles</category>
        
      </item>
    
      <item>
        <title>Marquee Long Text In Textview</title>
        <description>&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;Use android:singline=”true” and make the TextView selected&lt;/p&gt;

&lt;h2 id=&quot;effect&quot;&gt;Effect&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/../assets/gif/20181110_marquee_tabs.gif&quot; alt=&quot;marquee demo gif&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;source-code&quot;&gt;Source Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jubincn/MarqueeTextViewDemo&quot;&gt;MarqueeTextViewDemo&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/articles/2018/11/10/marquee-long-text-in-textview.html</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2018/11/10/marquee-long-text-in-textview.html</guid>
        
        
        <category>articles</category>
        
      </item>
    
      <item>
        <title>Android Studio Custom Todo</title>
        <description>&lt;h2 id=&quot;todo-in-android-studio&quot;&gt;TODO In Android Studio&lt;/h2&gt;
&lt;h4 id=&quot;there-is-a-tool-window-named-todo-in-android-studio-from-which-we-can-find-all-todo-tags-in-our-project-besides-the-built-in-todo-and-fixme-tag-android-studio-provides-us-with-custom-tags&quot;&gt;There is a tool window named TODO in Android Studio, from which we can find all ‘TODO’ tags in our project. Besides the built in TODO and FIXME tag, Android Studio provides us with custom tags.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/pic/20181023-1-todo-in-AS.png&quot; alt=&quot;TODO In Android Studio&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;how-to-add-custom-todo-tags&quot;&gt;How to add custom TODO tags&lt;/h2&gt;
&lt;h4 id=&quot;open-todo-window-click-filter-button---edit-filters-and-an-add-pattern-dialog-will-show&quot;&gt;Open TODO window, click “filter” button -&amp;gt; “Edit Filters” and an “Add Pattern” dialog will show.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/pic/20181023-4-edit-filters.png&quot; alt=&quot;Find Edit Filters Dialog&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;click--button-and-add-custom-todo-tags-in-the-popup&quot;&gt;Click “+” button and add custom TODO tags in the popup.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/pic/20181023-2-add-in-patterns-panel.png&quot; alt=&quot;Add in Patterns Panel&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;change-the-regex-in-pattern-and-you-can-also-replace-default-color-scheme-with-custom-colors&quot;&gt;Change the regex in Pattern, and you can also replace default color scheme with custom colors.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/pic/20181023-3-add-with-params.png&quot; alt=&quot;Customize Pattern And Color&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;custom-filters&quot;&gt;Custom filters&lt;/h2&gt;
&lt;h4 id=&quot;in-the-same-popup-shown-in-step-1-click--in-filters-panel&quot;&gt;In the same popup shown in step 1, click “+” in Filters panel.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/pic/20181023-6-add-fitler.png&quot; alt=&quot;Add Filter&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;input-filter-name-and-select-patterns&quot;&gt;Input filter name and select patterns.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/pic/20181023-5-edit-filter.png&quot; alt=&quot;Edit Filter&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;use-custom-filters&quot;&gt;Use custom Filters&lt;/h2&gt;
&lt;h4 id=&quot;those-custom-filters-will-show-in-popup-after-click-filter-button-in-todo-window&quot;&gt;Those custom filters will show in popup after click “filter” button in TODO window.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/pic/20181023-7-select-filter.png&quot; alt=&quot;select Filters&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 23 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/articles/2018/10/23/android-studio-custom-todo.html</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2018/10/23/android-studio-custom-todo.html</guid>
        
        
        <category>articles</category>
        
      </item>
    
      <item>
        <title>Interactive Rebase Using Sourcetree</title>
        <description>&lt;h3 id=&quot;official-docs&quot;&gt;Official Docs&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.atlassian.com/blog/sourcetree/interactive-rebase-sourcetree&quot;&gt;Interactive rebase in Sourcetree&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;screenshot&quot;&gt;Screenshot&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.atlassian.com/blog/sourcetree/interactive-rebase-sourcetree&quot;&gt;The Official Blog&lt;/a&gt; is concise and sufficient. And I put a screenshot here to make it easier to understand.&lt;/p&gt;

&lt;h4 id=&quot;process-in-gif&quot;&gt;Process in gif&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/gif/20181017-interactive-rebase-using-sourcetree.gif&quot; alt=&quot;Interactive Rebase&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;final-git-history-screenshot&quot;&gt;Final Git History Screenshot&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/pic/20181017-interactive-rebase-final-git-history.png&quot; alt=&quot;Final Git History&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 17 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/articles/2018/10/17/interactive-rebase-using-sourcetree.html</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2018/10/17/interactive-rebase-using-sourcetree.html</guid>
        
        
        <category>articles</category>
        
      </item>
    
      <item>
        <title>Annotations For Java Friendly Kotlin Translate</title>
        <description>
&lt;p&gt;&lt;a href=&quot;https://proandroiddev.com/annotations-for-your-java-friendly-kotlin-code-badfbedec14&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于部分使用kotlin，部分使用java的android项目而言，java和kotlin的相互调用是个大坑。这篇文章讲了kotlin里常用的与java调用相关的注解。&lt;/p&gt;

&lt;h2 id=&quot;java注解&quot;&gt;Java注解&lt;/h2&gt;
&lt;h3 id=&quot;jvmfield&quot;&gt;JvmField&lt;/h3&gt;
&lt;h4 id=&quot;用途&quot;&gt;用途&lt;/h4&gt;
&lt;p&gt;让Kotlin编译器将这个字段编译为public，而不是生成getter/setter。&lt;/p&gt;

&lt;h4 id=&quot;常用场景&quot;&gt;常用场景&lt;/h4&gt;
&lt;p&gt;在Companion或其他object中的字段。&lt;/p&gt;

&lt;h4 id=&quot;原理&quot;&gt;原理&lt;/h4&gt;
&lt;p&gt;看下源码，简单说就是getter/setter -&amp;gt; public field&lt;/p&gt;

&lt;hr /&gt;
&lt;h5 id=&quot;没有jvmfield的时候&quot;&gt;没有JvmField的时候&lt;/h5&gt;

&lt;h6 id=&quot;object&quot;&gt;object&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object Constants {    
    val PERMISSIONS = listOf(&quot;Internet&quot;, &quot;Location&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Constant {
   @NotNull
   private static final List PERMISSIONS;
   public static final Constant INSTANCE;

   @NotNull
   public final List getPERMISSIONS() {
      return PERMISSIONS;
   }

   static {
      Constant var0 = new Constant();
      INSTANCE = var0;
      PERMISSIONS = CollectionsKt.listOf(new String[]{&quot;Internet&quot;, &quot;Location&quot;});
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h6 id=&quot;class&quot;&gt;class&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Constant {
    val PERMISSIONS = listOf(&quot;Internet&quot;, &quot;Location&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Constant {
   @NotNull
   private final List PERMISSIONS = CollectionsKt.listOf(new String[]{&quot;Internet&quot;, &quot;Location&quot;});

   @NotNull
   public final List getPERMISSIONS() {
      return this.PERMISSIONS;
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;有jvmfield的时候&quot;&gt;有JvmField的时候&lt;/h5&gt;
&lt;h6 id=&quot;object-1&quot;&gt;object&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object Constant {
    @JvmField
    val PERMISSIONS = listOf(&quot;Internet&quot;, &quot;Location&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Constant {
   @JvmField
   @NotNull
   public static final List PERMISSIONS;
   public static final Constant INSTANCE;

   static {
      Constant var0 = new Constant();
      INSTANCE = var0;
      PERMISSIONS = CollectionsKt.listOf(new String[]{&quot;Internet&quot;, &quot;Location&quot;});
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h6 id=&quot;class-1&quot;&gt;class&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Constant {
    @JvmField
    val PERMISSIONS = listOf(&quot;Internet&quot;, &quot;Location&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Constant {
   @JvmField
   @NotNull
   public final List PERMISSIONS = CollectionsKt.listOf(new String[]{&quot;Internet&quot;, &quot;Location&quot;});
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;jvmstatic&quot;&gt;JvmStatic&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;用在方法上：生成一个静态方法。&lt;/li&gt;
  &lt;li&gt;用在字段上：生成静态的getter和setter&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;用在方法上&quot;&gt;用在方法上&lt;/h4&gt;
&lt;p&gt;不带@JvmStatic的时候，这个方法是一个实例方法，调用时需要使用Utils.INSTANCE.doSomething()&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object Utils {
    fun doSomething(){  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Utils {
   public static final Utils INSTANCE;

   public final void doSomething() {
   }

   static {
      Utils var0 = new Utils();
      INSTANCE = var0;
   }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用JvmStatic后，Kotlin编译器会将此方法转为static方法，此时可以直接用Utils.doSomething()&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object Utils {
    @JvmStatic
    fun doSomething(){  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Utils {
   public static final Utils INSTANCE;

   @JvmStatic
   public static final void doSomething() {
   }

   static {
      Utils var0 = new Utils();
      INSTANCE = var0;
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;用在变量上&quot;&gt;用在变量上&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object Utils {
    var values = listOf(&quot;Test 1&quot;, &quot;Test 2&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Utils {
   @NotNull
   private static List values;
   public static final Utils INSTANCE;

   @NotNull
   public final List getValues() {
      return values;
   }

   public final void setValues(@NotNull List var1) {
      Intrinsics.checkParameterIsNotNull(var1, &quot;&amp;lt;set-?&amp;gt;&quot;);
      values = var1;
   }

   static {
      Utils var0 = new Utils();
      INSTANCE = var0;
      values = CollectionsKt.listOf(new String[]{&quot;Test 1&quot;, &quot;Test 2&quot;});
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;对于变量，JvmStatic的作用是将setter和getter改为static方法。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object Utils {
    @JvmStatic
    var values = listOf(&quot;Test 1&quot;, &quot;Test 2&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Utils {
   @NotNull
   private static List values;
   public static final Utils INSTANCE;  

   @NotNull
   public static final List getValues() {
      return values;
   }

   public static final void setValues(@NotNull List var0) {
      Intrinsics.checkParameterIsNotNull(var0, &quot;&amp;lt;set-?&amp;gt;&quot;);
      values = var0;
   }

   static {
      Utils var0 = new Utils();
      INSTANCE = var0;
      values = CollectionsKt.listOf(new String[]{&quot;Test 1&quot;, &quot;Test 2&quot;});
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;不能使用jvmstatic的场景&quot;&gt;不能使用JvmStatic的场景&lt;/h4&gt;
&lt;p&gt;当一个成员变量含有open, override或const的modifier时，不能使用@JvmStatic注解。&lt;/p&gt;

&lt;h3 id=&quot;jvmoverloads&quot;&gt;JvmOverloads&lt;/h3&gt;
&lt;p&gt;在Kotlin中，有默认构造方法，这些方法在使用kotlin调用的时候很方便，相当于定义了多个构造函数。但使用Java调用时，却最多只能用两个：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;含有全部参数的构造函数。&lt;/li&gt;
  &lt;li&gt;在所有参数都有默认参数的时候，可以调用它的无参构造函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;kotlin中带默认参数构造函数的使用&quot;&gt;Kotlin中带默认参数构造函数的使用&lt;/h4&gt;
&lt;p&gt;下面这个构造函数，三个参数都带有默认值&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class User constructor (
        val name: String = &quot;Test&quot;,
        val lastName: String = &quot;Testy&quot;,
        val age: Int = 0
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用时可以这么用：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val user1 = User()
val user2 = User(name = &quot;Bruno&quot;)
val user3 = User(name = &quot;Bruno&quot;, lastName = &quot;Aybar&quot;)
val user4 = User(name = &quot;Bruno&quot;, lastName = &quot;Aybar&quot;, age = 21)
val user5 = User(lastName = &quot;Aybar&quot;)
val user6 = User(lastName = &quot;Aybar&quot;, age = 21)
val user7 = User(age = 21)
val user8 = User(age = 21, name = &quot;Bruno&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;@JvmOverloads能部分解决这个问题，使用@JvmOverloads后，这里会多出三个构造方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class User {
   @JvmOverloads
   public User(@NotNull String name, @NotNull String lastName) {
      this(name, lastName, 0, 4, (DefaultConstructorMarker)null);
   }

   @JvmOverloads
   public User(@NotNull String name) {
      this(name, (String)null, 0, 6, (DefaultConstructorMarker)null);
   }

   @JvmOverloads
   public User() {
      this((String)null, (String)null, 0, 7, (DefaultConstructorMarker)null);
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;filejvmname-jvmname-getjvmname&quot;&gt;@file:JvmName @JvmName @get:JvmName&lt;/h3&gt;
&lt;p&gt;给某个文件或者方法，字段换一个Java调用时使用的名字。&lt;/p&gt;
&lt;h4 id=&quot;filejvmname&quot;&gt;@file:JvmName&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//file name: Utils.kt
fun doSomething() { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在Java中可以这么调用：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UtilsKt.doSomething();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;加上@file:JvmName(“Utils”)后，就可以使用Utils这个名字来调用了。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//file name: Utils.kt
@file:JvmName(&quot;Utils&quot;)
fun doSomething() { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在Java中调用：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Utils.doSomething();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;方法名也可以改，例如：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//file name: Utils.kt
@file:JvmName(&quot;Utils&quot;)
@JvmName(&quot;doSomethingElse&quot;)
fun doSomething() { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在Java中调用：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Java
Utils.doSomethingElse();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在Kotlin中调用：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Kotlin
Utils.doSomething()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 30 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/articles/2018/07/30/annotations-for-java-friendly-kotlin-translate.html</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2018/07/30/annotations-for-java-friendly-kotlin-translate.html</guid>
        
        
        <category>articles</category>
        
      </item>
    
      <item>
        <title>Use Ui Automator Viewer To Get Current Viewer</title>
        <description>&lt;h3 id=&quot;what-is-ui-automator-viewer&quot;&gt;What is UI Automator Viewer?&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;The uiautomatorviewer tool provides a convenient GUI to scan and analyze the UI components currently displayed on an Android device.     – &lt;a href=&quot;https://developer.android.com/training/testing/ui-automator#ui-automator-viewer&quot;&gt;From developer.android.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;why-should-i-care-about-ui-automator-viewer&quot;&gt;Why should I care about UI Automator Viewer&lt;/h3&gt;
&lt;p&gt;With uiautomatorviewer, we can inspect the layout hierarchy and view the properties of UI components that are visible on the foreground of the device. For example, we can get the view hierarchy of Play Store.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/../assets/gif/ui-automator-demo.gif&quot; alt=&quot;uiautomatorviewer demo gif&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;how-to-use&quot;&gt;How to use?&lt;/h3&gt;
&lt;p&gt;uiautomatorviewer is a tool delivered with android sdk. For mac users, you can find it in {HOME}/Library/Android/sdk/tools/bin/uiautomatorviewer. This is an binary execuable file and so you can exec it in terminal. Click device screenshot button and the view hierarchy is in front of you!
&lt;img src=&quot;/../assets/pic/20180528-device-screenshot.png&quot; alt=&quot;device screenshot button&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 28 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/articles/2018/05/28/use-ui-automator-viewer-to-get-current-viewer.html</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2018/05/28/use-ui-automator-viewer-to-get-current-viewer.html</guid>
        
        
        <category>articles</category>
        
      </item>
    
      <item>
        <title>Intro To Ashmem Note</title>
        <description>&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Ashmem memory dies when the process dies.&lt;/li&gt;
  &lt;li&gt;Ashmem allows fork first and then share memory.&lt;/li&gt;
  &lt;li&gt;Ashmem save memory by unpinning memory pages, reclaim unit for ashmem is section.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;what-is-ashmem&quot;&gt;What is Ashmem&lt;/h2&gt;
&lt;p&gt;Ashmem is short for Android Shared Memory.&lt;/p&gt;

&lt;h3 id=&quot;what-does-ashmen-do&quot;&gt;What does Ashmen do?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Share memory between process.&lt;/li&gt;
  &lt;li&gt;A mechanism for Linux to recalim memory if it find itself under memory pressure.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;how-does-ashmem-allowed-other-process-to-share-memory&quot;&gt;How does ashmem allowed other process to share memory&lt;/h3&gt;
&lt;p&gt;I didn’t understand the whole process. It seems has something to do with binder and mmap. Read &lt;a href=&quot;http://notjustburritos.tumblr.com/post/21442138796/an-introduction-to-android-shared-memory&quot;&gt;original post&lt;/a&gt; for more details.&lt;/p&gt;

&lt;h3 id=&quot;why-is-ashmem-better&quot;&gt;Why is ashmem better?&lt;/h3&gt;
&lt;font color=&quot;red&quot;&gt;important&lt;/font&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;The ashmem memory dies when the process dies.&lt;/strong&gt; (No chance killing process with some memory reserves)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Ashmem allows a process share memory after it has already forked&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;how-does-ashmem-save-memory&quot;&gt;How does ashmem save memory?&lt;/h3&gt;
&lt;font color=&quot;red&quot;&gt;important&lt;/font&gt;

&lt;p&gt;Asmem allows a process to designate some pages of its memory as reclaimable. This is called unpinning a section of memory.&lt;/p&gt;

&lt;p&gt;When the section is unpinned, OS can reclaim the pages and use them if memory goes low.&lt;/p&gt;

&lt;p&gt;The process can pin these pages back. The driver will return “ASHMEM_NOT_PURGED” or “ASHMEM_WAS_PURGED” to indicate whether these pages are reclaimed while they are unpinned. If they are purged, the data is gone. This is good for handling cache data.&lt;/p&gt;

&lt;p&gt;Using ashmem, a process can cache gressively without warrying about memory pressure.&lt;/p&gt;

&lt;h3 id=&quot;how-ashmem-decide-when-to-claim-memory&quot;&gt;How ashmem decide when to claim memory?&lt;/h3&gt;
&lt;p&gt;Ashmem registers a shrinker and call the shrink function when memory is low, telling it how many pages it want freed.&lt;/p&gt;

&lt;p&gt;Ashmem reclaim unpinned pages using LRU algorithm.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Ashmem will free an entire section of memory.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;how-ashmem-do-all-these-things&quot;&gt;How ashmem do all these things&lt;/h3&gt;
&lt;p&gt;See the original post for more details.&lt;/p&gt;

&lt;h4 id=&quot;original-post&quot;&gt;&lt;a href=&quot;http://notjustburritos.tumblr.com/post/21442138796/an-introduction-to-android-shared-memory&quot;&gt;Original Post&lt;/a&gt;&lt;/h4&gt;
</description>
        <pubDate>Sun, 27 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/articles/2018/05/27/intro-to-ashmem-note.html</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2018/05/27/intro-to-ashmem-note.html</guid>
        
        
        <category>articles</category>
        
      </item>
    
  </channel>
</rss>
