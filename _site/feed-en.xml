<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bin's Blog</title>
    <description>Bin's Blog
</description>
    <link>http://localhost:4000/index.html</link>
    <atom:link href="http://localhost:4000/feed-en.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 12 Dec 2018 08:57:17 +0800</pubDate>
    <lastBuildDate>Wed, 12 Dec 2018 08:57:17 +0800</lastBuildDate>
    <generator>Jekyll v3.6.3</generator>
    
    
      <item>
        <title>Detect Image Format Using Java</title>
        <description>&lt;h2 id=&quot;suffix-is-not-enough&quot;&gt;Suffix is not enough&lt;/h2&gt;
&lt;p&gt;We used to judge a file type by its suffix. For example, .gif for gif format, .jpg for jpeg and .png for png files. However, this is not a reliable way to detect a file type since we can change file suffix to any name we want. Check file header is a more preferable to detect file type.&lt;/p&gt;

&lt;h2 id=&quot;file-header&quot;&gt;File header&lt;/h2&gt;
&lt;p&gt;There is a file header for every common used image file, we can detect file type using it. The popular file header is listed below:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Extended WebP
```Java
/**&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Each VP8X WebP image has “features” byte following its ChunkHeader(‘VP8X’)
 */
private static final int EXTENDED_WEBP_HEADER_LENGTH = 21;
```&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Simple WebP
```Java
/**&lt;/li&gt;
  &lt;li&gt;Each WebP header should consist of at least 20 bytes and start&lt;/li&gt;
  &lt;li&gt;with “RIFF” bytes followed by some 4 bytes and “WEBP” bytes.&lt;/li&gt;
  &lt;li&gt;More detailed description if WebP can be found here:&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.com/speed/webp/docs/riff_container&quot;&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://developers.google.com/speed/webp/docs/riff_container&amp;lt;/a&amp;gt;
 */
private static final int SIMPLE_WEBP_HEADER_LENGTH = 20;
```&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;JPEG
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private static final byte[] JPEG_HEADER = new byte[] {(byte) 0xFF, (byte)0xD8, (byte)0xFF}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;PNG
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private static final byte[] PNG_HEADER = new byte[] {
    (byte) 0x89,
    'P', 'N', 'G',
    (byte) 0x0D, (byte) 0x0A, (byte) 0x1A, (byte) 0x0A};
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;GIF&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private static final byte[] GIF_HEADER_87A = ImageFormatCheckerUtils.asciiBytes(&quot;GIF87a&quot;);
private static final byte[] GIF_HEADER_89A = ImageFormatCheckerUtils.asciiBytes(&quot;GIF89a&quot;);

public static byte[] asciiBytes(String value) {
  Preconditions.checkNotNull(value);
  try {
    return value.getBytes(&quot;ASCII&quot;);
  } catch (UnsupportedEncodingException uee) {
    // won't happen
    throw new RuntimeException(&quot;ASCII not found!&quot;, uee);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;BMP_HEADER_LENGTH&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * Every bmp image starts with &quot;BM&quot; bytes
 */
private static final byte[] BMP_HEADER = ImageFormatCheckerUtils.asciiBytes(&quot;BM&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;detect-file-type-with-fresco&quot;&gt;Detect file type with Fresco&lt;/h2&gt;
&lt;p&gt;There is a helper class in Fresco which can help detect image file type with an input stream. We can use that util class in our project:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /**
    * @return {@link com.facebook.imageformat.DefaultImageFormats}
    */
   @NonNull
   public static ImageFormat getImageFormat(@NonNull ContentResolver cr, @NonNull Uri imageUri) {
       if (cr == null || imageUri == null) {
           return ImageFormat.UNKNOWN;
       }

       ImageFormat result = null;
       try {
           InputStream imageInputStream = cr.openInputStream(imageUri);
           if (imageInputStream != null) {
               result = ImageFormatChecker.getImageFormat(imageInputStream);
           }
       } catch (FileNotFoundException e) {
           Log.printErrStackTrace(TAG, e,
                   &quot;FileNotFoundException in getImageFormat, uri: &quot; + imageUri);
       } catch (IOException e) {
           Log.printErrStackTrace(TAG, e, &quot;IOException in getImageFormat, uri: &quot; + imageUri);
       }

       return (result == null) ? ImageFormat.UNKNOWN : result;
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;detect-file-type-with-plain-codes&quot;&gt;Detect file type with plain codes&lt;/h2&gt;
&lt;p&gt;If Fresco is not available, we can write our own util class like those in Fresco. Let’s go through source codes of Fresco and find out how things works.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;getImageFormat is a static method, which calls instance method determineImageFormat(InputStream)
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * Tries to read up to MAX_HEADER_LENGTH bytes from InputStream is and use read bytes to
 * determine type of the image contained in is. If provided input stream does not support mark,
 * then this method consumes data from is and it is not safe to read further bytes from is after
 * this method returns. Otherwise, if mark is supported, it will be used to preserve original
 * content of is.
 * @param is
 * @return ImageFormat matching content of is InputStream or UNKNOWN if no type is suitable
 * @throws IOException if exception happens during read
 */
public static ImageFormat getImageFormat(final InputStream is) throws IOException {
  return getInstance().determineImageFormat(is);
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;determineImageFormat do the hard jobs. It read header from input stream and determine the ImageFormat.
```Java
public ImageFormat determineImageFormat(final InputStream is) throws IOException {
  Preconditions.checkNotNull(is);
  final byte[] imageHeaderBytes = new byte[mMaxHeaderLength];
  final int headerSize = readHeaderFromStream(mMaxHeaderLength, is, imageHeaderBytes);&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;if (mCustomImageFormatCheckers != null) {
    for (ImageFormat.FormatChecker formatChecker : mCustomImageFormatCheckers) {
      ImageFormat format = formatChecker.determineFormat(imageHeaderBytes, headerSize);
      if (format != null &amp;amp;&amp;amp; format != ImageFormat.UNKNOWN) {
        return format;
      }
    }
  }
  ImageFormat format = mDefaultFormatChecker.determineFormat(imageHeaderBytes, headerSize);
  if (format == null) {
    format = ImageFormat.UNKNOWN;
  }
  return format;
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3. There is a default implementation to calculate mMaxHeaderLength, which covers most commonly used image format.

```Java
/**
  * Maximum header size for any image type.
  *
  * &amp;lt;p&amp;gt;This determines how much data {@link ImageFormatChecker#getImageFormat(InputStream) reads
  * from a stream. After changing any of the type detection algorithms, or adding a new one, this
  * value should be edited.
  */
 final int MAX_HEADER_LENGTH = Ints.max(
     EXTENDED_WEBP_HEADER_LENGTH,
     SIMPLE_WEBP_HEADER_LENGTH,
     JPEG_HEADER_LENGTH,
     PNG_HEADER_LENGTH,
     GIF_HEADER_LENGTH,
     BMP_HEADER_LENGTH);

@Override
public int getHeaderSize() {
   return MAX_HEADER_LENGTH;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Read header into a byte array with maximum header size. We can be sure that the header info is stored in that byte array.
```Java
/**
    &lt;ul&gt;
      &lt;li&gt;Reads up to maxHeaderLength bytes from is InputStream. If mark is supported by is, it is&lt;/li&gt;
      &lt;li&gt;used to restore content of the stream after appropriate amount of data is read.&lt;/li&gt;
      &lt;li&gt;Read bytes are stored in imageHeaderBytes, which should be capable of storing&lt;/li&gt;
      &lt;li&gt;maxHeaderLength bytes.&lt;/li&gt;
      &lt;li&gt;@param maxHeaderLength the maximum header length&lt;/li&gt;
      &lt;li&gt;@param is&lt;/li&gt;
      &lt;li&gt;@param imageHeaderBytes&lt;/li&gt;
      &lt;li&gt;@return number of bytes read from is&lt;/li&gt;
      &lt;li&gt;@throws IOException
 */
private static int readHeaderFromStream(
 int maxHeaderLength,
 final InputStream is,
 final byte[] imageHeaderBytes)
 throws IOException {
  Preconditions.checkNotNull(is);
  Preconditions.checkNotNull(imageHeaderBytes);
  Preconditions.checkArgument(imageHeaderBytes.length &amp;gt;= maxHeaderLength);&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;// If mark is supported by the stream, use it to let the owner of the stream re-read the same
  // data. Otherwise, just consume some data.
  if (is.markSupported()) {
    try {
      is.mark(maxHeaderLength);
      return ByteStreams.read(is, imageHeaderBytes, 0, maxHeaderLength);
    } finally {
      is.reset();
    }
  } else {
    return ByteStreams.read(is, imageHeaderBytes, 0, maxHeaderLength);
  }
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
5. We can set our custom ImageFormatChecker to detect those image format not in the list. And if our custom checker failed, the default ImageFormatChecker will still work.
```java
if (mCustomImageFormatCheckers != null) {
  for (ImageFormat.FormatChecker formatChecker : mCustomImageFormatCheckers) {
    ImageFormat format = formatChecker.determineFormat(imageHeaderBytes, headerSize);
    if (format != null &amp;amp;&amp;amp; format != ImageFormat.UNKNOWN) {
      return format;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Detect image format with header byte and header size.
```Java
/**
    &lt;ul&gt;
      &lt;li&gt;Tries to match imageHeaderByte and headerSize against every known image format. If any match&lt;/li&gt;
      &lt;li&gt;succeeds, corresponding ImageFormat is returned.
 *&lt;/li&gt;
      &lt;li&gt;@param headerBytes the header bytes to check&lt;/li&gt;
      &lt;li&gt;@param headerSize the available header size&lt;/li&gt;
      &lt;li&gt;@return ImageFormat for given imageHeaderBytes or UNKNOWN if no such type could be recognized
 */
@Nullable
@Override
public final ImageFormat determineFormat(byte[] headerBytes, int headerSize) {
  Preconditions.checkNotNull(headerBytes);&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;if (WebpSupportStatus.isWebpHeader(headerBytes, 0, headerSize)) {
    return getWebpFormat(headerBytes, headerSize);
  }&lt;/p&gt;

&lt;p&gt;if (isJpegHeader(headerBytes, headerSize)) {
    return DefaultImageFormats.JPEG;
  }&lt;/p&gt;

&lt;p&gt;if (isPngHeader(headerBytes, headerSize)) {
    return DefaultImageFormats.PNG;
  }&lt;/p&gt;

&lt;p&gt;if (isGifHeader(headerBytes, headerSize)) {
    return DefaultImageFormats.GIF;
  }&lt;/p&gt;

&lt;p&gt;if (isBmpHeader(headerBytes, headerSize)) {
    return DefaultImageFormats.BMP;
  }&lt;/p&gt;

&lt;p&gt;return ImageFormat.UNKNOWN;
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
* Check is WebP
```Java
/**
 * Checks if imageHeaderBytes contains WEBP_RIFF_BYTES and WEBP_NAME_BYTES and if the
 * header is long enough to be WebP's header.
 * WebP file format can be found here:
 * &amp;lt;a href=&quot;https://developers.google.com/speed/webp/docs/riff_container&quot;&amp;gt;
 *   https://developers.google.com/speed/webp/docs/riff_container&amp;lt;/a&amp;gt;
 * @param imageHeaderBytes image header bytes
 * @return true if imageHeaderBytes contains a valid webp header
 */
public static boolean isWebpHeader(
    final byte[] imageHeaderBytes,
    final int offset,
    final int headerSize) {
  return headerSize &amp;gt;= SIMPLE_WEBP_HEADER_LENGTH &amp;amp;&amp;amp;
      matchBytePattern(imageHeaderBytes, offset, WEBP_RIFF_BYTES) &amp;amp;&amp;amp;
      matchBytePattern(imageHeaderBytes, offset + 8, WEBP_NAME_BYTES);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Check is Jpeg
```Java
/**&lt;/li&gt;
  &lt;li&gt;Checks if imageHeaderBytes starts with SOI (start of image) marker, followed by 0xFF.&lt;/li&gt;
  &lt;li&gt;If headerSize is lower than 3 false is returned.&lt;/li&gt;
  &lt;li&gt;Description of jpeg format can be found here:&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.w3.org/Graphics/JPEG/itu-t81.pdf&quot;&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;http://www.w3.org/Graphics/JPEG/itu-t81.pdf&amp;lt;/a&amp;gt;&lt;/li&gt;
  &lt;li&gt;Annex B deals with compressed data format&lt;/li&gt;
  &lt;li&gt;@param imageHeaderBytes&lt;/li&gt;
  &lt;li&gt;@param headerSize&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;@return true if imageHeaderBytes starts with SOI_BYTES and headerSize &amp;gt;= 3
 */
private static boolean isJpegHeader(final byte[] imageHeaderBytes, final int headerSize) {
  return headerSize &amp;gt;= JPEG_HEADER.length &amp;amp;&amp;amp;
   ImageFormatCheckerUtils.startsWithPattern(imageHeaderBytes, JPEG_HEADER);
}
```&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Check is PNG
```Java
/**&lt;/li&gt;
  &lt;li&gt;Checks if array consisting of first headerSize bytes of imageHeaderBytes&lt;/li&gt;
  &lt;li&gt;starts with png signature. More information on PNG can be found there:&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Portable_Network_Graphics&quot;&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;http://en.wikipedia.org/wiki/Portable_Network_Graphics&amp;lt;/a&amp;gt;&lt;/li&gt;
  &lt;li&gt;@param imageHeaderBytes&lt;/li&gt;
  &lt;li&gt;@param headerSize&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;@return true if imageHeaderBytes starts with PNG_HEADER
 */
private static boolean isPngHeader(final byte[] imageHeaderBytes, final int headerSize) {
  return headerSize &amp;gt;= PNG_HEADER.length &amp;amp;&amp;amp;
   ImageFormatCheckerUtils.startsWithPattern(imageHeaderBytes, PNG_HEADER);
}
```&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Check is GIF
```Java
/**&lt;/li&gt;
  &lt;li&gt;Checks if first headerSize bytes of imageHeaderBytes constitute a valid header for a gif image.&lt;/li&gt;
  &lt;li&gt;Details on GIF header can be found &lt;a href=&quot;http://www.w3.org/Graphics/GIF/spec-gif89a.txt&quot;&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;on page 7&amp;lt;/a&amp;gt;&lt;/li&gt;
  &lt;li&gt;@param imageHeaderBytes&lt;/li&gt;
  &lt;li&gt;@param headerSize&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;@return true if imageHeaderBytes is a valid header for a gif image
 */
private static boolean isGifHeader(final byte[] imageHeaderBytes, final int headerSize) {
  if (headerSize &amp;lt; GIF_HEADER_LENGTH) {
 return false;
  }
  return ImageFormatCheckerUtils.startsWithPattern(imageHeaderBytes, GIF_HEADER_87A) ||
   ImageFormatCheckerUtils.startsWithPattern(imageHeaderBytes, GIF_HEADER_89A);
}
```&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Check is BMP
```Java
/**&lt;/li&gt;
  &lt;li&gt;Checks if first headerSize bytes of imageHeaderBytes constitute a valid header for a bmp image.&lt;/li&gt;
  &lt;li&gt;Details on BMP header can be found &lt;a href=&quot;http://www.onicos.com/staff/iz/formats/bmp.html&quot;&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&amp;lt;/a&amp;gt;&lt;/li&gt;
  &lt;li&gt;@param imageHeaderBytes&lt;/li&gt;
  &lt;li&gt;@param headerSize&lt;/li&gt;
  &lt;li&gt;@return true if imageHeaderBytes is a valid header for a bmp image
 */
private static boolean isBmpHeader(final byte[] imageHeaderBytes, final int headerSize) {
  if (headerSize &amp;lt; BMP_HEADER.length) {
 return false;
  }
  return ImageFormatCheckerUtils.startsWithPattern(imageHeaderBytes, BMP_HEADER);
}
```&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Util Class
```Java
private static boolean matchBytePattern(
 final byte[] byteArray,
 final int offset,
 final byte[] pattern) {
  if (pattern == null || byteArray == null) {
 return false;
  }
  if (pattern.length + offset &amp;gt; byteArray.length) {
 return false;
  }&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;for (int i = 0; i &amp;lt; pattern.length; ++i) {
    if (byteArray[i + offset] != pattern[i]) {
      return false;
    }
  }&lt;/p&gt;

&lt;p&gt;return true;
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
```Java
/**
 * Checks if byteArray interpreted as sequence of bytes starts with pattern
 * starting at position equal to offset.
 * @param byteArray the byte array to be checked
 * @param pattern the pattern to check
 * @return true if byteArray starts with pattern
 */
public static boolean startsWithPattern(
    final byte[] byteArray,
    final byte[] pattern) {
  Preconditions.checkNotNull(byteArray);
  Preconditions.checkNotNull(pattern);
  if (pattern.length &amp;gt; byteArray.length) {
    return false;
  }

  for (int i = 0; i &amp;lt; pattern.length; ++i) {
    if (byteArray[i] != pattern[i]) {
      return false;
    }
  }

  return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * Helper method that transforms provided string into it's byte representation
 * using ASCII encoding.
 * @param value the string to use
 * @return byte array representing ascii encoded value
 */
public static byte[] asciiBytes(String value) {
  Preconditions.checkNotNull(value);
  try {
    return value.getBytes(&quot;ASCII&quot;);
  } catch (UnsupportedEncodingException uee) {
    // won't happen
    throw new RuntimeException(&quot;ASCII not found!&quot;, uee);
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 05 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/articles/2018/12/05/Detect-image-format-using-java.html</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2018/12/05/Detect-image-format-using-java.html</guid>
        
        
        <category>articles</category>
        
      </item>
    
      <item>
        <title>Incompatibleclasschangeerror Kotlin Java Inheritance</title>
        <description>&lt;h2 id=&quot;stack-trace&quot;&gt;Stack Trace&lt;/h2&gt;
&lt;p&gt;java.lang.IncompatibleClassChangeError: Expected ‘java.lang.String com.example.jubin.componiontest.Child.TAG’ to be a instance field rather than a static field (declaration of ‘com.example.jubin.componiontest.Child’ appears in /data/app/com.example.jubin.componiontest–ve-LsY3llWd0XWRXem1Kw==/base.apk)
       at com.example.jubin.componiontest.Child.visitInner(Child.kt:12)
       at com.example.jubin.componiontest.MainActivity$onCreate$1.onClick(MainActivity.kt:15)
       at android.view.View.performClick(View.java:6597)
       at android.view.View.performClickInternal(View.java:6574)
       at android.view.View.access$3100(View.java:778)
       at android.view.View$PerformClick.run(View.java:25885)
       at android.os.Handler.handleCallback(Handler.java:873)
       at android.os.Handler.dispatchMessage(Handler.java:99)
       at android.os.Looper.loop(Looper.java:193)
       at android.app.ActivityThread.main(ActivityThread.java:6680)
       at java.lang.reflect.Method.invoke(Native Method)
       at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)
       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)&lt;/p&gt;

&lt;h2 id=&quot;symptom&quot;&gt;Symptom&lt;/h2&gt;
&lt;p&gt;The codes can compile, but will crash at runtime.&lt;/p&gt;

&lt;h2 id=&quot;code-snippet&quot;&gt;Code Snippet&lt;/h2&gt;
&lt;h3 id=&quot;parentjava&quot;&gt;Parent.java&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;package com.example.jubin.componiontest2;

public abstract class Parent {
    protected final String TAG = &quot;ParentTag&quot;;

    public abstract void visitInner();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;childkt&quot;&gt;Child.kt&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;package com.example.jubin.componiontest2

import android.util.Log

class Child : Parent() {
    companion object {
        private val TAG = &quot;ChildTag&quot;
    }

    override fun visitInner() {

        Log.d(TAG, &quot;CHILD, tag: ${Child.TAG}&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;cause&quot;&gt;Cause&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TAG&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;Log.d(TAG, &quot;CHILD, tag: ${Child.TAG}&quot;)&lt;/code&gt; refer to &lt;code class=&quot;highlighter-rouge&quot;&gt;TAG&lt;/code&gt; in parent instead of local one. The comparison result of bytecode is :
&lt;img src=&quot;/../assets/pic/20181202-compare.png&quot; alt=&quot;Bytecode Comparison&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 02 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/articles/2018/12/02/IncompatibleClassChangeError-Kotlin-Java-Inheritance.html</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2018/12/02/IncompatibleClassChangeError-Kotlin-Java-Inheritance.html</guid>
        
        
        <category>articles</category>
        
      </item>
    
      <item>
        <title>Android Binder Study Note</title>
        <description>&lt;h2 id=&quot;tldr&quot;&gt;TL,DR&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Driver based IPC.&lt;/li&gt;
  &lt;li&gt;There is only one copy for Binder IPC and hence its efficient.
    &lt;ul&gt;
      &lt;li&gt;For client: Copy data from user space to kernel space, 1 time.&lt;/li&gt;
      &lt;li&gt;For server: Using mmap to share response memory, 0 time.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;how-to-find-service&quot;&gt;How to find service?&lt;/h2&gt;
&lt;p&gt;Binder token is used to locate service and they are registered in ServiceManager. There is a default locater with fixed token(seems to be 0) and client will ask locater for address.&lt;/p&gt;

&lt;h2 id=&quot;why-use-binder-instead-of-other-linux-ipc&quot;&gt;Why use Binder instead of other Linux IPC?&lt;/h2&gt;
&lt;p&gt;Shared memory is more efficient but its also error-prone. Pipe and message queue is less efficient since they need 2 memory copy.&lt;/p&gt;

&lt;h2 id=&quot;security-model&quot;&gt;Security model&lt;/h2&gt;
&lt;p&gt;Based on UID and PID, and filters to guarantee security.&lt;/p&gt;

&lt;h2 id=&quot;async-or-sync&quot;&gt;Async or sync?&lt;/h2&gt;
&lt;p&gt;Synchronous.&lt;/p&gt;

&lt;h2 id=&quot;reference-counting&quot;&gt;Reference Counting&lt;/h2&gt;
&lt;p&gt;Since Binder object is shared by another process, Binder use reference counting to track it.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35519585&quot;&gt;写给 Android 应用工程师的 Binder 原理剖析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.dre.vanderbilt.edu/~schmidt/cs282/PDFs/android-binder-ipc.pdf&quot;&gt;Android Binder IPC pdf&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/articles/2018/11/19/android-binder-study-note.html</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2018/11/19/android-binder-study-note.html</guid>
        
        
        <category>articles</category>
        
      </item>
    
      <item>
        <title>Marquee Long Text In Textview</title>
        <description>&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;Use android:singline=”true” and make the TextView selected&lt;/p&gt;

&lt;h2 id=&quot;effect&quot;&gt;Effect&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/../assets/gif/20181110_marquee_tabs.gif&quot; alt=&quot;marquee demo gif&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;source-code&quot;&gt;Source Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jubincn/MarqueeTextViewDemo&quot;&gt;MarqueeTextViewDemo&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/articles/2018/11/10/marquee-long-text-in-textview.html</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2018/11/10/marquee-long-text-in-textview.html</guid>
        
        
        <category>articles</category>
        
      </item>
    
      <item>
        <title>Android Studio Custom Todo</title>
        <description>&lt;h2 id=&quot;todo-in-android-studio&quot;&gt;TODO In Android Studio&lt;/h2&gt;
&lt;h4 id=&quot;there-is-a-tool-window-named-todo-in-android-studio-from-which-we-can-find-all-todo-tags-in-our-project-besides-the-built-in-todo-and-fixme-tag-android-studio-provides-us-with-custom-tags&quot;&gt;There is a tool window named TODO in Android Studio, from which we can find all ‘TODO’ tags in our project. Besides the built in TODO and FIXME tag, Android Studio provides us with custom tags.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/pic/20181023-1-todo-in-AS.png&quot; alt=&quot;TODO In Android Studio&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;how-to-add-custom-todo-tags&quot;&gt;How to add custom TODO tags&lt;/h2&gt;
&lt;h4 id=&quot;open-todo-window-click-filter-button---edit-filters-and-an-add-pattern-dialog-will-show&quot;&gt;Open TODO window, click “filter” button -&amp;gt; “Edit Filters” and an “Add Pattern” dialog will show.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/pic/20181023-4-edit-filters.png&quot; alt=&quot;Find Edit Filters Dialog&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;click--button-and-add-custom-todo-tags-in-the-popup&quot;&gt;Click “+” button and add custom TODO tags in the popup.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/pic/20181023-2-add-in-patterns-panel.png&quot; alt=&quot;Add in Patterns Panel&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;change-the-regex-in-pattern-and-you-can-also-replace-default-color-scheme-with-custom-colors&quot;&gt;Change the regex in Pattern, and you can also replace default color scheme with custom colors.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/pic/20181023-3-add-with-params.png&quot; alt=&quot;Customize Pattern And Color&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;custom-filters&quot;&gt;Custom filters&lt;/h2&gt;
&lt;h4 id=&quot;in-the-same-popup-shown-in-step-1-click--in-filters-panel&quot;&gt;In the same popup shown in step 1, click “+” in Filters panel.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/pic/20181023-6-add-fitler.png&quot; alt=&quot;Add Filter&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;input-filter-name-and-select-patterns&quot;&gt;Input filter name and select patterns.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/pic/20181023-5-edit-filter.png&quot; alt=&quot;Edit Filter&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;use-custom-filters&quot;&gt;Use custom Filters&lt;/h2&gt;
&lt;h4 id=&quot;those-custom-filters-will-show-in-popup-after-click-filter-button-in-todo-window&quot;&gt;Those custom filters will show in popup after click “filter” button in TODO window.&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/pic/20181023-7-select-filter.png&quot; alt=&quot;select Filters&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 23 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/articles/2018/10/23/android-studio-custom-todo.html</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2018/10/23/android-studio-custom-todo.html</guid>
        
        
        <category>articles</category>
        
      </item>
    
      <item>
        <title>Interactive Rebase Using Sourcetree</title>
        <description>&lt;h3 id=&quot;official-docs&quot;&gt;Official Docs&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.atlassian.com/blog/sourcetree/interactive-rebase-sourcetree&quot;&gt;Interactive rebase in Sourcetree&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;screenshot&quot;&gt;Screenshot&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.atlassian.com/blog/sourcetree/interactive-rebase-sourcetree&quot;&gt;The Official Blog&lt;/a&gt; is concise and sufficient. And I put a screenshot here to make it easier to understand.&lt;/p&gt;

&lt;h4 id=&quot;process-in-gif&quot;&gt;Process in gif&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/gif/20181017-interactive-rebase-using-sourcetree.gif&quot; alt=&quot;Interactive Rebase&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;final-git-history-screenshot&quot;&gt;Final Git History Screenshot&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/pic/20181017-interactive-rebase-final-git-history.png&quot; alt=&quot;Final Git History&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 17 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/articles/2018/10/17/interactive-rebase-using-sourcetree.html</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2018/10/17/interactive-rebase-using-sourcetree.html</guid>
        
        
        <category>articles</category>
        
      </item>
    
      <item>
        <title>Annotations For Java Friendly Kotlin Translate</title>
        <description>
&lt;p&gt;&lt;a href=&quot;https://proandroiddev.com/annotations-for-your-java-friendly-kotlin-code-badfbedec14&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于部分使用kotlin，部分使用java的android项目而言，java和kotlin的相互调用是个大坑。这篇文章讲了kotlin里常用的与java调用相关的注解。&lt;/p&gt;

&lt;h2 id=&quot;java注解&quot;&gt;Java注解&lt;/h2&gt;
&lt;h3 id=&quot;jvmfield&quot;&gt;JvmField&lt;/h3&gt;
&lt;h4 id=&quot;用途&quot;&gt;用途&lt;/h4&gt;
&lt;p&gt;让Kotlin编译器将这个字段编译为public，而不是生成getter/setter。&lt;/p&gt;

&lt;h4 id=&quot;常用场景&quot;&gt;常用场景&lt;/h4&gt;
&lt;p&gt;在Companion或其他object中的字段。&lt;/p&gt;

&lt;h4 id=&quot;原理&quot;&gt;原理&lt;/h4&gt;
&lt;p&gt;看下源码，简单说就是getter/setter -&amp;gt; public field&lt;/p&gt;

&lt;hr /&gt;
&lt;h5 id=&quot;没有jvmfield的时候&quot;&gt;没有JvmField的时候&lt;/h5&gt;

&lt;h6 id=&quot;object&quot;&gt;object&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object Constants {    
    val PERMISSIONS = listOf(&quot;Internet&quot;, &quot;Location&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Constant {
   @NotNull
   private static final List PERMISSIONS;
   public static final Constant INSTANCE;

   @NotNull
   public final List getPERMISSIONS() {
      return PERMISSIONS;
   }

   static {
      Constant var0 = new Constant();
      INSTANCE = var0;
      PERMISSIONS = CollectionsKt.listOf(new String[]{&quot;Internet&quot;, &quot;Location&quot;});
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h6 id=&quot;class&quot;&gt;class&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Constant {
    val PERMISSIONS = listOf(&quot;Internet&quot;, &quot;Location&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Constant {
   @NotNull
   private final List PERMISSIONS = CollectionsKt.listOf(new String[]{&quot;Internet&quot;, &quot;Location&quot;});

   @NotNull
   public final List getPERMISSIONS() {
      return this.PERMISSIONS;
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;有jvmfield的时候&quot;&gt;有JvmField的时候&lt;/h5&gt;
&lt;h6 id=&quot;object-1&quot;&gt;object&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object Constant {
    @JvmField
    val PERMISSIONS = listOf(&quot;Internet&quot;, &quot;Location&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Constant {
   @JvmField
   @NotNull
   public static final List PERMISSIONS;
   public static final Constant INSTANCE;

   static {
      Constant var0 = new Constant();
      INSTANCE = var0;
      PERMISSIONS = CollectionsKt.listOf(new String[]{&quot;Internet&quot;, &quot;Location&quot;});
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h6 id=&quot;class-1&quot;&gt;class&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Constant {
    @JvmField
    val PERMISSIONS = listOf(&quot;Internet&quot;, &quot;Location&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Constant {
   @JvmField
   @NotNull
   public final List PERMISSIONS = CollectionsKt.listOf(new String[]{&quot;Internet&quot;, &quot;Location&quot;});
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;jvmstatic&quot;&gt;JvmStatic&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;用在方法上：生成一个静态方法。&lt;/li&gt;
  &lt;li&gt;用在字段上：生成静态的getter和setter&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;用在方法上&quot;&gt;用在方法上&lt;/h4&gt;
&lt;p&gt;不带@JvmStatic的时候，这个方法是一个实例方法，调用时需要使用Utils.INSTANCE.doSomething()&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object Utils {
    fun doSomething(){  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Utils {
   public static final Utils INSTANCE;

   public final void doSomething() {
   }

   static {
      Utils var0 = new Utils();
      INSTANCE = var0;
   }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用JvmStatic后，Kotlin编译器会将此方法转为static方法，此时可以直接用Utils.doSomething()&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object Utils {
    @JvmStatic
    fun doSomething(){  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Utils {
   public static final Utils INSTANCE;

   @JvmStatic
   public static final void doSomething() {
   }

   static {
      Utils var0 = new Utils();
      INSTANCE = var0;
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;用在变量上&quot;&gt;用在变量上&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object Utils {
    var values = listOf(&quot;Test 1&quot;, &quot;Test 2&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Utils {
   @NotNull
   private static List values;
   public static final Utils INSTANCE;

   @NotNull
   public final List getValues() {
      return values;
   }

   public final void setValues(@NotNull List var1) {
      Intrinsics.checkParameterIsNotNull(var1, &quot;&amp;lt;set-?&amp;gt;&quot;);
      values = var1;
   }

   static {
      Utils var0 = new Utils();
      INSTANCE = var0;
      values = CollectionsKt.listOf(new String[]{&quot;Test 1&quot;, &quot;Test 2&quot;});
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;对于变量，JvmStatic的作用是将setter和getter改为static方法。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object Utils {
    @JvmStatic
    var values = listOf(&quot;Test 1&quot;, &quot;Test 2&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Utils {
   @NotNull
   private static List values;
   public static final Utils INSTANCE;  

   @NotNull
   public static final List getValues() {
      return values;
   }

   public static final void setValues(@NotNull List var0) {
      Intrinsics.checkParameterIsNotNull(var0, &quot;&amp;lt;set-?&amp;gt;&quot;);
      values = var0;
   }

   static {
      Utils var0 = new Utils();
      INSTANCE = var0;
      values = CollectionsKt.listOf(new String[]{&quot;Test 1&quot;, &quot;Test 2&quot;});
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;不能使用jvmstatic的场景&quot;&gt;不能使用JvmStatic的场景&lt;/h4&gt;
&lt;p&gt;当一个成员变量含有open, override或const的modifier时，不能使用@JvmStatic注解。&lt;/p&gt;

&lt;h3 id=&quot;jvmoverloads&quot;&gt;JvmOverloads&lt;/h3&gt;
&lt;p&gt;在Kotlin中，有默认构造方法，这些方法在使用kotlin调用的时候很方便，相当于定义了多个构造函数。但使用Java调用时，却最多只能用两个：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;含有全部参数的构造函数。&lt;/li&gt;
  &lt;li&gt;在所有参数都有默认参数的时候，可以调用它的无参构造函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;kotlin中带默认参数构造函数的使用&quot;&gt;Kotlin中带默认参数构造函数的使用&lt;/h4&gt;
&lt;p&gt;下面这个构造函数，三个参数都带有默认值&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class User constructor (
        val name: String = &quot;Test&quot;,
        val lastName: String = &quot;Testy&quot;,
        val age: Int = 0
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用时可以这么用：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val user1 = User()
val user2 = User(name = &quot;Bruno&quot;)
val user3 = User(name = &quot;Bruno&quot;, lastName = &quot;Aybar&quot;)
val user4 = User(name = &quot;Bruno&quot;, lastName = &quot;Aybar&quot;, age = 21)
val user5 = User(lastName = &quot;Aybar&quot;)
val user6 = User(lastName = &quot;Aybar&quot;, age = 21)
val user7 = User(age = 21)
val user8 = User(age = 21, name = &quot;Bruno&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;@JvmOverloads能部分解决这个问题，使用@JvmOverloads后，这里会多出三个构造方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class User {
   @JvmOverloads
   public User(@NotNull String name, @NotNull String lastName) {
      this(name, lastName, 0, 4, (DefaultConstructorMarker)null);
   }

   @JvmOverloads
   public User(@NotNull String name) {
      this(name, (String)null, 0, 6, (DefaultConstructorMarker)null);
   }

   @JvmOverloads
   public User() {
      this((String)null, (String)null, 0, 7, (DefaultConstructorMarker)null);
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;filejvmname-jvmname-getjvmname&quot;&gt;@file:JvmName @JvmName @get:JvmName&lt;/h3&gt;
&lt;p&gt;给某个文件或者方法，字段换一个Java调用时使用的名字。&lt;/p&gt;
&lt;h4 id=&quot;filejvmname&quot;&gt;@file:JvmName&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//file name: Utils.kt
fun doSomething() { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在Java中可以这么调用：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UtilsKt.doSomething();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;加上@file:JvmName(“Utils”)后，就可以使用Utils这个名字来调用了。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//file name: Utils.kt
@file:JvmName(&quot;Utils&quot;)
fun doSomething() { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在Java中调用：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Utils.doSomething();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;方法名也可以改，例如：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//file name: Utils.kt
@file:JvmName(&quot;Utils&quot;)
@JvmName(&quot;doSomethingElse&quot;)
fun doSomething() { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在Java中调用：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Java
Utils.doSomethingElse();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在Kotlin中调用：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Kotlin
Utils.doSomething()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 30 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/articles/2018/07/30/annotations-for-java-friendly-kotlin-translate.html</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2018/07/30/annotations-for-java-friendly-kotlin-translate.html</guid>
        
        
        <category>articles</category>
        
      </item>
    
      <item>
        <title>Use Ui Automator Viewer To Get Current Viewer</title>
        <description>&lt;h3 id=&quot;what-is-ui-automator-viewer&quot;&gt;What is UI Automator Viewer?&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;The uiautomatorviewer tool provides a convenient GUI to scan and analyze the UI components currently displayed on an Android device.     – &lt;a href=&quot;https://developer.android.com/training/testing/ui-automator#ui-automator-viewer&quot;&gt;From developer.android.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;why-should-i-care-about-ui-automator-viewer&quot;&gt;Why should I care about UI Automator Viewer&lt;/h3&gt;
&lt;p&gt;With uiautomatorviewer, we can inspect the layout hierarchy and view the properties of UI components that are visible on the foreground of the device. For example, we can get the view hierarchy of Play Store.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/../assets/gif/ui-automator-demo.gif&quot; alt=&quot;uiautomatorviewer demo gif&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;how-to-use&quot;&gt;How to use?&lt;/h3&gt;
&lt;p&gt;uiautomatorviewer is a tool delivered with android sdk. For mac users, you can find it in {HOME}/Library/Android/sdk/tools/bin/uiautomatorviewer. This is an binary execuable file and so you can exec it in terminal. Click device screenshot button and the view hierarchy is in front of you!
&lt;img src=&quot;/../assets/pic/20180528-device-screenshot.png&quot; alt=&quot;device screenshot button&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 28 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/articles/2018/05/28/use-ui-automator-viewer-to-get-current-viewer.html</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2018/05/28/use-ui-automator-viewer-to-get-current-viewer.html</guid>
        
        
        <category>articles</category>
        
      </item>
    
      <item>
        <title>Intro To Ashmem Note</title>
        <description>&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Ashmem memory dies when the process dies.&lt;/li&gt;
  &lt;li&gt;Ashmem allows fork first and then share memory.&lt;/li&gt;
  &lt;li&gt;Ashmem save memory by unpinning memory pages, reclaim unit for ashmem is section.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;what-is-ashmem&quot;&gt;What is Ashmem&lt;/h2&gt;
&lt;p&gt;Ashmem is short for Android Shared Memory.&lt;/p&gt;

&lt;h3 id=&quot;what-does-ashmen-do&quot;&gt;What does Ashmen do?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Share memory between process.&lt;/li&gt;
  &lt;li&gt;A mechanism for Linux to recalim memory if it find itself under memory pressure.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;how-does-ashmem-allowed-other-process-to-share-memory&quot;&gt;How does ashmem allowed other process to share memory&lt;/h3&gt;
&lt;p&gt;I didn’t understand the whole process. It seems has something to do with binder and mmap. Read &lt;a href=&quot;http://notjustburritos.tumblr.com/post/21442138796/an-introduction-to-android-shared-memory&quot;&gt;original post&lt;/a&gt; for more details.&lt;/p&gt;

&lt;h3 id=&quot;why-is-ashmem-better&quot;&gt;Why is ashmem better?&lt;/h3&gt;
&lt;font color=&quot;red&quot;&gt;important&lt;/font&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;The ashmem memory dies when the process dies.&lt;/strong&gt; (No chance killing process with some memory reserves)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Ashmem allows a process share memory after it has already forked&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;how-does-ashmem-save-memory&quot;&gt;How does ashmem save memory?&lt;/h3&gt;
&lt;font color=&quot;red&quot;&gt;important&lt;/font&gt;

&lt;p&gt;Asmem allows a process to designate some pages of its memory as reclaimable. This is called unpinning a section of memory.&lt;/p&gt;

&lt;p&gt;When the section is unpinned, OS can reclaim the pages and use them if memory goes low.&lt;/p&gt;

&lt;p&gt;The process can pin these pages back. The driver will return “ASHMEM_NOT_PURGED” or “ASHMEM_WAS_PURGED” to indicate whether these pages are reclaimed while they are unpinned. If they are purged, the data is gone. This is good for handling cache data.&lt;/p&gt;

&lt;p&gt;Using ashmem, a process can cache gressively without warrying about memory pressure.&lt;/p&gt;

&lt;h3 id=&quot;how-ashmem-decide-when-to-claim-memory&quot;&gt;How ashmem decide when to claim memory?&lt;/h3&gt;
&lt;p&gt;Ashmem registers a shrinker and call the shrink function when memory is low, telling it how many pages it want freed.&lt;/p&gt;

&lt;p&gt;Ashmem reclaim unpinned pages using LRU algorithm.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Ashmem will free an entire section of memory.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;how-ashmem-do-all-these-things&quot;&gt;How ashmem do all these things&lt;/h3&gt;
&lt;p&gt;See the original post for more details.&lt;/p&gt;

&lt;h4 id=&quot;original-post&quot;&gt;&lt;a href=&quot;http://notjustburritos.tumblr.com/post/21442138796/an-introduction-to-android-shared-memory&quot;&gt;Original Post&lt;/a&gt;&lt;/h4&gt;
</description>
        <pubDate>Sun, 27 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/articles/2018/05/27/intro-to-ashmem-note.html</link>
        <guid isPermaLink="true">http://localhost:4000/articles/2018/05/27/intro-to-ashmem-note.html</guid>
        
        
        <category>articles</category>
        
      </item>
    
  </channel>
</rss>
